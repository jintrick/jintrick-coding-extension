---
id: v1.16.2
type: fix
status: closed
created: 2025-02-23
fixed_commit: a6e3ce5
---

# Issue: Python Linter における Lazy Import およびスコープ解析の誤検知修正

## 概要
Python Linter (`hooks/scripts/linters/py.cjs`) において、関数内部でのインポート（Lazy Import）がネストした関数（クロージャ）から参照された際に「未定義」と誤検知される問題、および `try-except` 等のブロック内でのインポートがグローバルシンボルとして正しく収集されない問題を修正する。

## 背景と問題点
v1.16.1 で導入された AST ベースの静的解析において、以下の不備があり、AI エージェントが生成した有効な Python コードを誤って `deny` したり、逆に不正なコードを見逃したりするケースが発生している。

1.  **クロージャのスコープ継承不備**: `check_node` において、関数（`FunctionDef`）の内部スコープを初期化する際、`final_globals`（グローバル定義）のみを参照しており、外側の関数のローカルスコープ（`read_scope`）を継承していない。これにより、外側の関数で Lazy Import したモジュールを内側の関数で利用するとエラーになる。
2.  **シンボル収集の再帰不足**: `collect_defs` (Pass 1) において、再帰的に探索するノード種別がホワイトリスト方式（`If`, `For`, `Try` 等）になっており、`ExceptHandler` などのネストしたノード内部の定義（Import, Assign）がスキップされている。これにより、`try-except` 内で定義されたシンボルがグローバルとして認識されない。
3.  **関数定義の一部が未検証**: 関数のデコレータ、引数のデフォルト値、型ヒント（Annotations）が `check_node` の走査対象から漏れており、そこで未定義の変数を使用しても検知できない、または走査順序によって誤検知を招く可能性がある。
4.  **物理的改行の評価漏れ (Critical)**: `write_file` ツールが書き込む際、文字列内の `\n` を物理的な改行として書き込む一方で、Linter が `ast.parse` を行う前にこの物理化をシミュレーションしていない。その結果、シングルクォート内の `\n` を含むコード（例: `val = ("\n", "Root")`）が Linter 上では正常（1行の文字列）と評価されるが、書き込み後のファイルでは不正な改行（SyntaxError）となる「見逃し」が発生している。
## 解決策
`hooks/scripts/linters/py.cjs` 内の Python 解析スクリプトを以下の通り修正する。

1.  **物理的改行のシミュレーション**: `ast.parse` を実行する前に、`content` 内の `\n` や `\r` を実際の改行コードに置換する。これにより、`write_file` ツールが書き込む最終的なファイルイメージに対して検証を行い、シングルクォート内での不正な改行（SyntaxError）を事前に検知する。
2.  **`collect_defs` の汎用化**: ホワイトリストによる再帰を廃止し、`ast.iter_fields` を用いた汎用的な再帰処理に変更する。ただし、新しいスコープを作成する `FunctionDef`, `ClassDef`, `Lambda`, コンプレヘンション（`ListComp` 等）の内部には立ち入らないように制御する。
3.  **`check_node` のクロージャ対応**: 関数およびクラスの内部走査を開始する際、`func_scope` を `set(final_globals) | set(read_scope)` で初期化し、外側のスコープを引き継げるようにする。
4.  **関数構成要素の完全走査**: `FunctionDef` 走査時に、本体（`body`）だけでなく、`decorator_list`、`returns`、および引数（`args`）のデフォルト値と注釈を、定義時のスコープ（`read_scope`）で明示的にチェックする。

## 実装内容詳細

### 0. 物理改行の置換
Node.js 側で `content.replace(/\\n/g, '\n')` を実行してから Python プロセスへ渡す。

### 1. `collect_defs` の修正
シンボル収集のロジックを以下のように変更する。

- **スキップ対象**: `FunctionDef`, `AsyncFunctionDef`, `ClassDef` (名前のみ収集して return), `ListComp`, `SetComp`, `DictComp`, `GeneratorExp`, `Lambda` (走査せず return)。
- **収集対象**: `Import`, `ImportFrom`, `Assign`, `AnnAssign`（既存ロジック維持）。
- **再帰**: 上記以外（`If`, `Try`, `ExceptHandler`, `With` 等）は `ast.iter_fields` で全子ノードを再帰走査する。

### 2. `check_node` の修正
スコープ管理のロジックを以下のように変更する。

- **`FunctionDef` / `AsyncFunctionDef`**:
    -   `node.decorator_list` を `read_scope` で `check_node` する。
    -   `node.returns` (型ヒント) を `read_scope` で `check_node` する。
    -   `node.args` 内の `defaults`, `kw_defaults` を `read_scope` で `check_node` する。
    -   `node.args` 内の各引数の `annotation` を `read_scope` で `check_node` する。
    -   `func_scope` を `set(final_globals) | set(read_scope)` で作成し、引数名を `add` する。
    -   `node.body` 内の各ノードを `func_scope` で `check_node` する。
- **`ClassDef`**:
    -   `decorator_list`, `bases`, `keywords` を `read_scope` で `check_node` する。
    -   `class_scope` を `set(final_globals) | set(read_scope)` で作成する。
    -   `node.body` を `class_scope` で走査する。

## ゴール
### 完了条件 (Acceptance Criteria)
- [ ] **物理改行による SyntaxError 検知**: シングルクォート内で `\n` を含む文字列が `deny` されること（物理的にファイルが壊れるのを防ぐ）。
- [ ] **クロージャ内の Lazy Import 許容**: 以下のコードが `allow` されること。
  ```python
  def outer():
      import os
      def inner():
          print(os.getcwd())
      inner()
  ```
- [ ] **Except ブロック内の Import 収集**: 以下のコードが `allow` されること。
  ```python
  try:
      import my_mod
  except ImportError:
      import os as my_mod
  def f():
      print(my_mod.getcwd())
  ```
- [ ] **引数デフォルト値の検証**: 以下のコードが `deny` されること（`undefined_var` が未定義のため）。
  ```python
  def f(arg=undefined_var):
      pass
  ```
- [ ] **前方参照の維持**: トップレベルでの前方参照 `print(x); x = 1` が引き続き `deny` されること。

## 検証手順 (Test Steps)
1.  **テストファイルの作成**: `tests/hooks/python_linter_v1.16.2.test.js` を作成し、上記の Acceptance Criteria に対応するテストケース（特にネストした関数と `try-except` 内のインポート）を記述する。
2.  **テスト実行**: `npx vitest tests/hooks/python_linter_v1.16.2.test.js` を実行し、すべてパスすることを確認する。
3.  **既存テストの回帰確認**: `npx vitest tests/hooks/python_linter.test.js` を実行し、既存のバリデーション機能に影響がないことを確認する。
