---
id: v1.15.0
type: feat
status: drafting
created: 2025-05-22
fixed_commit: 
---

# Issue: IDD Sync Hook の実装 (Auto-discovery & Parser-based)

## 概要
`git commit -m "vX.Y.Z ..."` の実行をインターセプトし、コミットメッセージ内のバージョン番号に基づいてマニフェストファイルを自動更新・ステージングする `BeforeTool` Hook を実装する。`smol-toml` を用いて JSON および TOML の構造的な正確性を担保し、プロジェクトルートの既知のファイルを自動検知する。

## 背景と問題点
- バージョン同期が手動作業に依存しており、コミット内容とマニフェストの状態に不整合が生じるリスクがある。
- 既存の同期処理では、ファイルのフォーマットが維持されず、不要な差分が発生する。
- 複数のマニフェストファイル（`package.json`, `gemini-extension.json`, `pyproject.toml`, `Cargo.toml` 等）を自動的に検知・更新する仕組みがない。
- `pyproject.toml` のように、バージョン番号の記述箇所が複数（`[project]` や `[tool.poetry]`）存在しうるファイルへの対応が必要。

## 解決策
Gemini CLI の `BeforeTool` Hook 機能を利用し、`run_shell_command` (特に `git commit`) を対象とした同期処理を実装する。
- **Auto-discovery & Validation**: プロジェクトルートをスキャンし、マニフェストファイルを自動検出する。単にファイルが存在するだけでなく、各形式に応じた `version` キーを構造的に持っているかを検証した上で同期対象に加える。
- **Command Rewriting (Anti-Git-Lock)**: フック内で `git add` を直接実行せず、`tool_input.command` を `git add <updated_files> && <original_command>` に書き換える。これにより、Git ロックの競合を回避し、アトミックな更新を実現する。
- **Parser-based Update**: `JSON.parse` および `smol-toml` パーサを用いてバージョンを一意に更新する。
- **Format Preservation**: JSON ファイルに対して、元のインデント（スペース/タブ）と末尾改行を検知・復元する。
- **Bundling Strategy**: `esbuild` を使用して、依存ライブラリ（`smol-toml`）をフックの成果物（.cjs）にバンドルし、配布性を高める。

## 実装内容詳細

### 1. 依存関係の追加とビルド設定
- `package.json`: `dependencies` に `smol-toml` を追加。
- `tools/build.cjs`: `hooks` 配列に `hooks/scripts/idd_sync_hook.cjs` を追加。`esbuild` の `bundle: true` 設定により、`smol-toml` は `dist/hooks/idd_sync_hook.cjs` にインライン化される。

### 2. Version キーの探索アルゴリズム
各ファイル形式に対し、以下の JSONPath 相当のキーを優先順に検索する。
- **package.json / gemini-extension.json**: `$.version`
- **pyproject.toml**: `$.project.version` (1st) > `$.tool.poetry.version` (2nd)
- **Cargo.toml**: `$.package.version`

### 3. 自動検知と検証プロセス (`hooks/scripts/idd_sync/discovery.cjs`)
以下のステップで同期対象を確定させる。
1. `fs.readdirSync('.')` で取得したファイル群から既知のマニフェスト（`package.json`, `gemini-extension.json`, `pyproject.toml`, `Cargo.toml`）を抽出。
2. `.idd-sync.json` が存在する場合、その `manifests` リストをマージ。
3. リストされた各ファイルに対し、対応するパーサでパースを実行。
4. **構造検証**: 形式ごとの `version` キーが存在し、かつその値が文字列（または更新可能な形式）であることを確認。
5. 検証を通過したファイルパスとキー情報のペアを `syncList` として返却。

### 4. Hook エントリポイントとコマンド書き換え (`hooks/scripts/idd_sync_hook.cjs`)
- **Matcher**: `run_shell_command`
- **Trigger**: `tool_input.command` が `git commit` を含み、且つ `-m` オプションの引数に `v\d+\.\d+\.\d+` 形式の文字列が含まれる場合。
- **処理フロー**:
  1. コミットメッセージからターゲットバージョンを抽出。
  2. `syncList` の各ファイルを更新し、ファイルシステムに書き込む。
  3. 更新されたファイルパスのリストを取得。
  4. **Command Rewriting**: 以下の形式で `hookSpecificOutput` を含む JSON を標準出力に返却する。
     ```javascript
     const updatedFiles = await syncVersions(targetVersion);
     if (updatedFiles.length > 0) {
       console.log(JSON.stringify({
         decision: 'allow',
         hookSpecificOutput: {
           tool_input: {
             ...tool_input,
             command: `git add ${updatedFiles.join(' ')} && ${tool_input.command}`
           }
         }
       }));
       process.exit(0);
     }
     ```

### 5. 影響範囲 (Affected Files)
- `package.json` (依存追加)
- `tools/build.cjs` (ビルド対象追加)
- `hooks/scripts/idd_sync_hook.cjs` (新規: エントリポイント)
- `hooks/scripts/idd_sync/discovery.cjs` (新規: 自動検知ロジック)
- `hooks/scripts/idd_sync/parsers.cjs` (新規: JSON/TOML パーサ)
- `hooks/scripts/idd_sync/sync.cjs` (新規: 同期コアロジック)
- `tests/hooks/idd_sync_hook.test.js` (新規: 統合テスト)

## テスト自動化仕様
Vitest を使用して `tests/hooks/idd_sync_hook.test.js` を作成し、以下の要件を満たすテストを実装せよ。

### 1. サンドボックス方式の採用
テスト実行中に一時ディレクトリ `tests/fixtures/idd-sync-sandbox/` を使用せよ。
- **セットアップ**: `beforeEach` で `fs.mkdirSync` を使用してディレクトリを作成し、テストケースごとに必要なマニフェストファイル（`package.json`, `pyproject.toml`, `Cargo.toml`）を配置せよ。
- **クリーンアップ**: `afterEach` で `fs.rmSync` を使用してディレクトリを再帰的に削除せよ。

### 2. 具体的なテストケース定義

| Case ID | テスト内容 | 入力条件 (コミットメッセージ / ファイル) | 期待値 (期待される JSON 出力) |
| :--- | :--- | :--- | :--- |
| Case 1 | `package.json` ルートバージョン更新 | `git commit -m "v1.2.3"` / `package.json` (version: 1.0.0) | `{ decision: "allow", hookSpecificOutput: { tool_input: { command: "git add package.json && git commit -m \"v1.2.3\"" } } }` |
| Case 2 | `pyproject.toml` `[project].version` 更新 | `git commit -m "v2.0.0"` / `pyproject.toml` (`[project]` セクション) | `{ decision: "allow", hookSpecificOutput: { tool_input: { command: "git add pyproject.toml && git commit -m \"v2.0.0\"" } } }` |
| Case 3 | `pyproject.toml` (Poetry) 更新 | `git commit -m "v3.0.0"` / `pyproject.toml` (`[tool.poetry]` セクション) | `{ decision: "allow", hookSpecificOutput: { tool_input: { command: "git add pyproject.toml && git commit -m \"v3.0.0\"" } } }` |
| Case 4 | コマンド書き換えの検証 | `git commit -m "v1.1.0"` / 任意のファイル | 実行コマンドが `git add <file> && git commit` に変換されていること |
| Case 5 | バージョン不在時のスキップ | `git commit -m "fix bug"` / 任意のファイル | `{ decision: "allow" }` (hookSpecificOutput が存在しないこと) |

### 3. 検証の自動化手順
- フックの `main` 関数を実行し、その標準出力（JSON）を `JSON.parse` せよ。
- `expect` を用いて、出力構造が `{ decision: "allow", hookSpecificOutput: { tool_input: { command: "..." } } }` であることを検証せよ。
- 書き換え後の `command` プロパティが `git add [ファイル名] && [元のコマンド]` の形式に合致していることを検証せよ。

## 検証手順 (Test Steps)
1. `npm install` を実行し `smol-toml` を導入。
2. `npm run build` を実行し、`dist/hooks/idd_sync_hook.cjs` が生成され、内部に `smol-toml` のコードが含まれていることを `grep` で確認。
3. `npm test tests/hooks/idd_sync_hook.test.js` を実行し、すべてのテストケースがパスすることを確認。
4. 実際の環境（サンドボックス外）で `git commit -m "vX.Y.Z"` を実行し、ファイル更新とステージングが連動することを確認。

## ゴール
- [ ] `git commit -m "v1.15.0 ..."` 実行時に `package.json` の `version` が `1.15.0` に更新されること。
- [ ] プロジェクトルートにある `pyproject.toml` が自動検知され、`[project].version` または `[tool.poetry].version` が更新されること。
- [ ] `.idd-sync.json` に記載された任意のファイルが、自動検知と競合せず正しく更新されること。
- [ ] **コマンド書き換えの検証**: Hook の返り値によって、実行コマンドが `git add <files> && git commit ...` に書き換えられ、アトミックにコミットされること。
- [ ] JSON ファイルのインデントスタイルと末尾改行が維持されること。
- [ ] `smol-toml` により TOML ファイルが有効な構造で出力されること（コメント消失は許容）。
- [ ] `esbuild` でビルドされた成果物が依存関係（`smol-toml`）を内包していること。
